# 트리거
```
데이터베이스 안의 특정 상황이나 동작,즉 이벤트가 발생할 경우에
자동으로 실행되는 기능을 정의하는 PL/SQL 서브프로그램이다.
```
> 트리거의 장점
```
1.데이터와 연관된 여러 작업을 수행하기 위해
    PL/SQL문 또는 서브프로그램을 일일이 실행해야 하는 번거로움을 줄인다.
    즉 데이터 관련 작업을 좀 더 간편하게 수행할 수 있습니다.
    -
2.제약조건 (constraints)만으로 구현이 어렵거나 불가능한 
    좀 더 복잡한 데이터규칙을 정할수 있어 수준 높은 데이터 정의가 가능하다.
    -
3.데이터 변경과 관련된 일련 정보를 기록할 수 있으며
    여러 사용자가 공유하는 데이터 보안성과 안정성
        그리고 문제가 발생시 대처 능력을 높일수 있다
```
> 주의사항
```
트리거는 특정 작업또는 이벤트 발생으로 다른 데이터 작업을 추가로 실행하기에
무분별하게 사용하면 데이터 베이스의 성능을 떨어뜨리는 원인이 된다.
```
> 이벤트 발생 시점
```
 ● 데이터 조작어(DML) : INSERT,UPDATE,DELETE
 ● 데이터 정의어(DDL) : CREATE,ALTER,DROP
 ● 데이터 베이스 동작 : SERVERERROR,LOGON,LOGOFF
                        STARTUP,SSHUTDOWN
```
>## 오라클 트리거 분류
+  DML 트리거
    ```
    INSERT,UPDATE,DELETE같은 DML명령어를 기점으로 동작함
    ```
+ DDL 트리거
    ```
    CREATE,ALTER,DROP와 같은 DDL명령어를 기점으로 동작함
    ```
+ INSTEAD OF 트리거
    ```
    VIEW(뷰)에 사용하는 DML 명령어를 기점으로 동작함
    ```
+ 시스템(system) 트리거
    ```
    데이터베이스나 스키마를 이벤트로 동작함
    ```
+ 단순(simple) 트리거
    ```
    다음 각 시점(timing point)에 동작함
    + 트리거를 작동시킬 문장이 실행되기 전 시점
    + 트리거를 작동시킬 문장이 실행된 후 시점
    + 트리거를 작동시킬 문장이 행에 영향을 미치기 전 시점
    + 트리거를 작동시킬 문장이 행에 영향을 준 후 시점
    ```
+ 복합(compound) 트리거
    ```
    단순 드리거의 여러가지 시점으로 동작함
    ```

- - -
# `DML 트리거`
## 트리거 형식 - 1 기본 
> DML트리거는 특정 테이블에 DML명령어를 실행할때 작동하는 트리거이다.
```SQL
CREATE [OR REPLACE] TRIGGER trigger_name
{BEFORE|AFTER} triggering_event ON table_name
--트리거가 작동할 타이밍을 지정한다.
--BEFORE은 DML명령어가 실행되기 전 시점,
--AFTER은 DML명령어가 실행된 후 시점에 트리거가 작동한다. 
[FOR EACH ROW]
--트리거를 실행하는 DML 문장에 한번만 실행을할지 DML 문장에 의해 영향받는 행별로 실행할지 지정
--생략하면 트리거는 DML명령어가 실행할때 한번만 실행이 된다.
--생략을 안한 경우 DML명령어에 영향을 받는 행별로 트리거를 작동하되
--WHEN 키워드와 함께 사용하면 DML명령어에 영향 받는 행중 트리거를 작동시킬
--행을 조건식으로 지정할수 있다.
[FOLLOWS | PRECEDES another_trigger]
--여러 관련 트리거의 실행순서를 정할수 있다.
[ENABLE/DISABLE]
--온 오프 모드 ( 활성화 된 상태로 트리거 생성)
[WHEN condifion]
--행 트리거 일경우에 조건을 걸어 특정 경우에만 트리거가 작동하도록 한다.
DECLARE
    declaration statements
BEGIN
    executeable statements
EXCEPTION
    exception_handling statements
END;
```
__예제__
```SQL
--고객이 업데이트되거나 삭제될때마다 테이블에 따로 기록을 한다할ㄸ
--기록할 테이블을 만든다.
CREATE TABLE audits(
    audit_id            NUMBER  GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    table_name          VARCHAR2(225),
    transaction_name    VARCHAR2(10),
    by_user             VARCHAR2(30),
    transaction_date    DATE
);

--GENERATED BY DEFAULT AS IDENTITY 시퀸스와 같은 맥락

--CUSTOMERS => CUSTOMERS_COPY로 사용
--트리거 생성
CREATE OR REPLACE TRIGGER customer_audit_trg
    --테이블의 행이 업데이트되거 삭제될경우 트리거가 작동한다.
    AFTER UPDATE OR DELETE
    ON CUSTOMERS_COPY
    --매 행이 AFTER UPDATE OR DELETE 상황일때마다 적용됨.
    FOR EACH ROW
DECLARE
    I_transaction VARCHAR2(10);
BEGIN
    --determine the transaction type
    --트랜잭션 타입을 결정하다.
    I_transaction := CASE
        WHEN UPDATING THEN 'UPDATE'
        WHEN DELETING THEN 'DELETE'
    END;
    
    --insert a row into the audit table
    INSERT INTO audits (table_name,transaction_name,by_user,transaction_date)
    VALUES('CUSTOMERS',I_transaction,USER,SYSDATE);
END;
/
```
> 트리거 발동
```sql
UPDATE
    customers_copy
SET
    credit_limit = 2000
WHERE
    customer_id = 10;
```
> 트리거 발동 확인
```sql
--수정
UPDATE
    customers_copy
SET
    credit_limit = 2000
WHERE
    customer_id = 10;

--삭제
DELETE FROM
    customers_copy
WHERE
    customer_id = 10;

SELECT * FROM audits;

  AUDIT_ID TABLE_NAME      TRANSACTION_NAME     BY_USER    TRANSACT
---------- --------------- -------------------- ---------- --------
         1 CUSTOMERS       UPDATE               C##OT      22/10/03
         2 CUSTOMERS       DELETE               C##OT      22/10/03
```
## 트리거 형식 - 2 문장 트리거
```
영향을 받는 행 수와 관계없이 테이블에서 트리거 이벤트가 발생할때마다
즉, 명령문 수준 트리거는 각 트랜잭션에 대해 한 번 실행됩니다.

EX) 테이블에서 1000개행을 업데이트 하는 경우 
해당 테이블의 명령문 수준 트리거는 한 번만 실행이 된다.
```
> ### 문장 트리거 용도
```
문장 트리거는 연결된 테이블의 데이터 변경 감시나 데이터 관련 활동에 자주 사용되지 않는다.
일반적으로, 테이블에서 수행될 수 있는 트랜잭션 종류에 대한 추가 보안 조치를 시행하는데 사용된다.
[FOR EACH ROW] 생략시 생성된다.
```
__기본구문__
```SQL
CREATE [OR REPLACE] TRIGGER trigger_name
    {BEFORE | AFTER } triggering_event 
    ON table_name
    --여러 관련 트리거의 실행 순서를 지정한다
    [FOLLOWS | PRECEDES another_trigger]
    [ENABLE / DISABLE ]
    [WHEN condition]
DECLARE
    declaration statements
BEGIN
    executable statements
EXCEPTION
    exception_handling statements
END;
```
__예제__
```SQL
/*
월 회계를 마감하는 날짜 기간인 28~31일까지 
고객의 신용을 업데이트 하도록 사용자를 제한한다고 가정한다.
--금일 10월 4일이므로 오류를 만들기위해서 3~5일로 수정
*/
CREATE OR REPLACE TRIGGER customers_credit_trg
    --credit_limit 열을 수정을 안하면 트리거는 작동하지 않는다.
    BEFORE UPDATE OF credit_limit
    ON customers_copy
DECLARE
    I_day_of_month NUMBER;
BEGIN
    --트랜잭션 타입을 결정한다.
    I_day_of_month := EXTRACT(DAY FROM sysdate);
    --EXTRACT(단위 FROM 날짜) 날짜에서 단위만 꺼내오는 함수
    
    IF I_day_of_month BETWEEN 3 AND 5 THEN
        raise_application_error(-20100,'Cannot update customer credit from 28th to 31st');
    END IF;
END;
/
```
__트리거 발동__
```SQL
ORA-20100: Cannot update customer credit from 28th to 31st
ORA-06512: "C##OT.CUSTOMERS_CREDIT_TRG",  9행
ORA-04088: 트리거 'C##OT.CUSTOMERS_CREDIT_TRG'의 수행시 오류
```
`raise_application_error 프로시저 내부에서 업데이트를 자동으로 롤백한다.`
<br>

## 트리거 형식 - 3 행 트리거
```
INSERT,UPDATE,DELETE와 같은 트리거 이벤트의 영향을 받는
각 행에 대해 한번씩 실행이 된다.

행 트리거는 
데이터 감사 및 데이터 유효성 검사와 같은 데이터 관련 활동에 유용합니다.

[FOR EACH ROW]를 작성하면된다.
```
__기본구문__
```SQL
CREATE OR REPLACE TRIGGER trigger_name
    BEFORE | AFTER
    INSERT OR DELETE OR UPDATE OF column1, column2, …
    ON table_name
    FOR EACH ROW
    REFERENCING OLD AS old_name
    NEW AS new_name
    WHEN (condition)
DECLARE
    …
BEGIN
    …
EXCEPTION
    …
END;
```
> 행 트리거 특징
```
+문장 트리거에서 적용가능한 기능은 행 트리거도 적용이 가능하다.
+행 트리거를 사용시 BEFORE와 AFTER의 값을 추적할수있다
```
> :OLD 열, :NEW 값
```SQL
--행 트리거는 단일 행의 컨택스트 내에서 실행되기에
--이전 열 값과 새 열 값에 엑세스(접근) 할수 있다

OLD : 트리거가 처리한 레코드의 원래 값을 저장
NEW  : 새 값을 포함

--여기서 NEW값과 OLD값을 참조해서 사용하려면
-- (:)를 붙여야 사용이 가능하다.
:OLD.column_name
:NEW.column_name

ex) credit_limit 열값을 확인하여 기존값과 새 값을 비교할수있다
IF :NEW.credit_limit > :OLD.credit_limit THEN
    --carry an action(실행문장)
END IF;

```
> :OLD,NEW 가용성
```
트리거 이벤트   :NEW    :OLD
    --          --      --
    INSERT      Y       N
    UPDATE      Y       Y
    DELETE      N       Y

REFERENCING절을 사용하여 재정의가 가능하다.
```
### `성능 고려 사항`
```
행 트리거는 행이 트리거 이벤트의 영향을 받을때마다 계속 실행이 된다.
10,000개를 수정을 하면 10,000번의 트리거가 실행이되므로 성능 문제가 발생할수있다.
따라서 ;
트리거를 실행하는 조건을 지정하려면 WHEN 절을 사용한다.
```
__예시__
```SQL
CREATE OR REPLACE TRIGGER 
    --트리거 발동 컬럼 지정
    BEFORE UPDATE OF credit_limit 
    ON customers
    FOR EACH ROW --행트리거
    --WHEN절로 제한
    WHEN NEW.credit_limit > 10000;
```
__행 트리거 예제__
```SQL
CREATE OR REPLACE TRIGGER cutomsers_update_credit_trg
    BEFORE UPDATE OF credit_limit
    ON customers_copy
    FOR EACH ROW
    WHEN (NEW.credit_limit>0)
    --WHEN 절에는 :를 사용하지 않는다.
BEGIN
    --check the credit limit
    -- 새값과 기존값을 가져와서 사용하기때문에 : 를붙인다
    IF :NEW.credit_limit >= 2*:OLD.credit_limit THEN
        raise_application_error(-20101,'the new credit' || :NEW.credit_limit || 
            ' cannot increase to more than double, the current credit ' || :OLD.credit_limit);
    END IF;
END;
```
__적용 예제__
```SQL
--기존 신용한도
SELECT credit_limit 
    FROM customers_copy 
WHERE customer_id=11;
--
CREDIT_LIMIT
------------
       22000
--한도를 2배를 늘릴경우 트리거 발동
UPDATE
    customers_copy
set
    credit_limit = credit_limit*2
WHERE
    customer_id=11;

ORA-20101: the new credit44000 cannot increase to more than double, the current credit 22000
ORA-06512: "C##OT.CUTOMSERS_UPDATE_CREDIT_TRG",  4행
ORA-04088: 트리거 'C##OT.CUTOMSERS_UPDATE_CREDIT_TRG'의 수행시 오류
```