# 트리거
```
데이터베이스 안의 특정 상황이나 동작,즉 이벤트가 발생할 경우에
자동으로 실행되는 기능을 정의하는 PL/SQL 서브프로그램이다.
```
> 트리거의 장점
```
1.데이터와 연관된 여러 작업을 수행하기 위해
    PL/SQL문 또는 서브프로그램을 일일이 실행해야 하는 번거로움을 줄인다.
    즉 데이터 관련 작업을 좀 더 간편하게 수행할 수 있습니다.
    -
2.제약조건 (constraints)만으로 구현이 어렵거나 불가능한 
    좀 더 복잡한 데이터규칙을 정할수 있어 수준 높은 데이터 정의가 가능하다.
    -
3.데이터 변경과 관련된 일련 정보를 기록할 수 있으며
    여러 사용자가 공유하는 데이터 보안성과 안정성
        그리고 문제가 발생시 대처 능력을 높일수 있다
```
> 주의사항
```
트리거는 특정 작업또는 이벤트 발생으로 다른 데이터 작업을 추가로 실행하기에
무분별하게 사용하면 데이터 베이스의 성능을 떨어뜨리는 원인이 된다.
```
> 이벤트 발생 시점
```
 ● 데이터 조작어(DML) : INSERT,UPDATE,DELETE
 ● 데이터 정의어(DDL) : CREATE,ALTER,DROP
 ● 데이터 베이스 동작 : SERVERERROR,LOGON,LOGOFF
                        STARTUP,SSHUTDOWN
```
>## 오라클 트리거 분류
+  DML 트리거
    ```
    INSERT,UPDATE,DELETE같은 DML명령어를 기점으로 동작함
    ```
+ DDL 트리거
    ```
    CREATE,ALTER,DROP와 같은 DDL명령어를 기점으로 동작함
    ```
+ INSTEAD OF 트리거
    ```
    VIEW(뷰)에 사용하는 DML 명령어를 기점으로 동작함
    ```
+ 시스템(system) 트리거
    ```
    데이터베이스나 스키마를 이벤트로 동작함
    ```
+ 단순(simple) 트리거
    ```
    다음 각 시점(timing point)에 동작함
    + 트리거를 작동시킬 문장이 실행되기 전 시점
    + 트리거를 작동시킬 문장이 실행된 후 시점
    + 트리거를 작동시킬 문장이 행에 영향을 미치기 전 시점
    + 트리거를 작동시킬 문장이 행에 영향을 준 후 시점
    ```
+ 복합(compound) 트리거
    ```
    단순 드리거의 여러가지 시점으로 동작함
    ```

- - -
# `DML 트리거`
## 트리거 형식 - 1 기본 
> DML트리거는 특정 테이블에 DML명령어를 실행할때 작동하는 트리거이다.
```SQL
CREATE [OR REPLACE] TRIGGER trigger_name
{BEFORE|AFTER} triggering_event ON table_name
--트리거가 작동할 타이밍을 지정한다.
--BEFORE은 DML명령어가 실행되기 전 시점,
--AFTER은 DML명령어가 실행된 후 시점에 트리거가 작동한다. 
[FOR EACH ROW]
--트리거를 실행하는 DML 문장에 한번만 실행을할지 DML 문장에 의해 영향받는 행별로 실행할지 지정
--생략하면 트리거는 DML명령어가 실행할때 한번만 실행이 된다.
--생략을 안한 경우 DML명령어에 영향을 받는 행별로 트리거를 작동하되
--WHEN 키워드와 함께 사용하면 DML명령어에 영향 받는 행중 트리거를 작동시킬
--행을 조건식으로 지정할수 있다.
[FOLLOWS | PRECEDES another_trigger]
--여러 관련 트리거의 실행순서를 정할수 있다.
[ENABLE/DISABLE]
--온 오프 모드 ( 활성화 된 상태로 트리거 생성)
[WHEN condifion]
--행 트리거 일경우에 조건을 걸어 특정 경우에만 트리거가 작동하도록 한다.
DECLARE
    declaration statements
BEGIN
    executeable statements
EXCEPTION
    exception_handling statements
END;
```
__예제__
```SQL
--고객이 업데이트되거나 삭제될때마다 테이블에 따로 기록을 한다할ㄸ
--기록할 테이블을 만든다.
CREATE TABLE audits(
    audit_id            NUMBER  GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    table_name          VARCHAR2(225),
    transaction_name    VARCHAR2(10),
    by_user             VARCHAR2(30),
    transaction_date    DATE
);

--GENERATED BY DEFAULT AS IDENTITY 시퀸스와 같은 맥락

--CUSTOMERS => CUSTOMERS_COPY로 사용
--트리거 생성
CREATE OR REPLACE TRIGGER customer_audit_trg
    --테이블의 행이 업데이트되거 삭제될경우 트리거가 작동한다.
    AFTER UPDATE OR DELETE
    ON CUSTOMERS_COPY
    --매 행이 AFTER UPDATE OR DELETE 상황일때마다 적용됨.
    FOR EACH ROW
DECLARE
    I_transaction VARCHAR2(10);
BEGIN
    --determine the transaction type
    --트랜잭션 타입을 결정하다.
    I_transaction := CASE
        WHEN UPDATING THEN 'UPDATE'
        WHEN DELETING THEN 'DELETE'
    END;
    
    --insert a row into the audit table
    INSERT INTO audits (table_name,transaction_name,by_user,transaction_date)
    VALUES('CUSTOMERS',I_transaction,USER,SYSDATE);
END;
/
```
> 트리거 발동
```sql
UPDATE
    customers_copy
SET
    credit_limit = 2000
WHERE
    customer_id = 10;
```
> 트리거 발동 확인
```sql
--수정
UPDATE
    customers_copy
SET
    credit_limit = 2000
WHERE
    customer_id = 10;

--삭제
DELETE FROM
    customers_copy
WHERE
    customer_id = 10;

SELECT * FROM audits;

  AUDIT_ID TABLE_NAME      TRANSACTION_NAME     BY_USER    TRANSACT
---------- --------------- -------------------- ---------- --------
         1 CUSTOMERS       UPDATE               C##OT      22/10/03
         2 CUSTOMERS       DELETE               C##OT      22/10/03
```
## 트리거 형식 - 2 문장 트리거
```
영향을 받는 행 수와 관계없이 테이블에서 트리거 이벤트가 발생할때마다
즉, 명령문 수준 트리거는 각 트랜잭션에 대해 한 번 실행됩니다.

EX) 테이블에서 1000개행을 업데이트 하는 경우 
해당 테이블의 명령문 수준 트리거는 한 번만 실행이 된다.
```
> ### 문장 트리거 용도
```
문장 트리거는 연결된 테이블의 데이터 변경 감시나 데이터 관련 활동에 자주 사용되지 않는다.
일반적으로, 테이블에서 수행될 수 있는 트랜잭션 종류에 대한 추가 보안 조치를 시행하는데 사용된다.
[FOR EACH ROW] 생략시 생성된다.
```
__기본구문__
```SQL
CREATE [OR REPLACE] TRIGGER trigger_name
    {BEFORE | AFTER } triggering_event 
    ON table_name
    --여러 관련 트리거의 실행 순서를 지정한다
    [FOLLOWS | PRECEDES another_trigger]
    [ENABLE / DISABLE ]
    [WHEN condition]
DECLARE
    declaration statements
BEGIN
    executable statements
EXCEPTION
    exception_handling statements
END;
```
__예제__
```SQL
/*
월 회계를 마감하는 날짜 기간인 28~31일까지 
고객의 신용을 업데이트 하도록 사용자를 제한한다고 가정한다.
--금일 10월 4일이므로 오류를 만들기위해서 3~5일로 수정
*/
CREATE OR REPLACE TRIGGER customers_credit_trg
    --credit_limit 열을 수정을 안하면 트리거는 작동하지 않는다.
    BEFORE UPDATE OF credit_limit
    ON customers_copy
DECLARE
    I_day_of_month NUMBER;
BEGIN
    --트랜잭션 타입을 결정한다.
    I_day_of_month := EXTRACT(DAY FROM sysdate);
    --EXTRACT(단위 FROM 날짜) 날짜에서 단위만 꺼내오는 함수
    
    IF I_day_of_month BETWEEN 3 AND 5 THEN
        raise_application_error(-20100,'Cannot update customer credit from 28th to 31st');
    END IF;
END;
/
```
__트리거 발동__
```SQL
ORA-20100: Cannot update customer credit from 28th to 31st
ORA-06512: "C##OT.CUSTOMERS_CREDIT_TRG",  9행
ORA-04088: 트리거 'C##OT.CUSTOMERS_CREDIT_TRG'의 수행시 오류
```
`raise_application_error 프로시저 내부에서 업데이트를 자동으로 롤백한다.`
<br>

## 트리거 형식 - 3 행 트리거
```
INSERT,UPDATE,DELETE와 같은 트리거 이벤트의 영향을 받는
각 행에 대해 한번씩 실행이 된다.

행 트리거는 
데이터 감사 및 데이터 유효성 검사와 같은 데이터 관련 활동에 유용합니다.

[FOR EACH ROW]를 작성하면된다.
```
__기본구문__
```SQL
CREATE OR REPLACE TRIGGER trigger_name
    BEFORE | AFTER
    INSERT OR DELETE OR UPDATE OF column1, column2, …
    ON table_name
    FOR EACH ROW
    REFERENCING OLD AS old_name
    NEW AS new_name
    WHEN (condition)
DECLARE
    …
BEGIN
    …
EXCEPTION
    …
END;
```
> 행 트리거 특징
```
+문장 트리거에서 적용가능한 기능은 행 트리거도 적용이 가능하다.
+행 트리거를 사용시 BEFORE와 AFTER의 값을 추적할수있다
```
> :OLD 열, :NEW 값
```SQL
--행 트리거는 단일 행의 컨택스트 내에서 실행되기에
--이전 열 값과 새 열 값에 엑세스(접근) 할수 있다

OLD : 트리거가 처리한 레코드의 원래 값을 저장
NEW  : 새 값을 포함

--여기서 NEW값과 OLD값을 참조해서 사용하려면
-- (:)를 붙여야 사용이 가능하다.
:OLD.column_name
:NEW.column_name

ex) credit_limit 열값을 확인하여 기존값과 새 값을 비교할수있다
IF :NEW.credit_limit > :OLD.credit_limit THEN
    --carry an action(실행문장)
END IF;

```
> :OLD,NEW 가용성
```
트리거 이벤트   :NEW    :OLD
    --          --      --
    INSERT      Y       N
    UPDATE      Y       Y
    DELETE      N       Y

REFERENCING절을 사용하여 재정의가 가능하다.
```
### `성능 고려 사항`
```
행 트리거는 행이 트리거 이벤트의 영향을 받을때마다 계속 실행이 된다.
10,000개를 수정을 하면 10,000번의 트리거가 실행이되므로 성능 문제가 발생할수있다.
따라서 ;
트리거를 실행하는 조건을 지정하려면 WHEN 절을 사용한다.
```
__예시__
```SQL
CREATE OR REPLACE TRIGGER 
    --트리거 발동 컬럼 지정
    BEFORE UPDATE OF credit_limit 
    ON customers
    FOR EACH ROW --행트리거
    --WHEN절로 제한
    WHEN NEW.credit_limit > 10000;
```
__행 트리거 예제__
```SQL
CREATE OR REPLACE TRIGGER cutomsers_update_credit_trg
    BEFORE UPDATE OF credit_limit
    ON customers_copy
    FOR EACH ROW
    WHEN (NEW.credit_limit>0)
    --WHEN 절에는 :를 사용하지 않는다.
BEGIN
    --check the credit limit
    -- 새값과 기존값을 가져와서 사용하기때문에 : 를붙인다
    IF :NEW.credit_limit >= 2*:OLD.credit_limit THEN
        raise_application_error(-20101,'the new credit' || :NEW.credit_limit || 
            ' cannot increase to more than double, the current credit ' || :OLD.credit_limit);
    END IF;
END;
```
__적용 예제__
```SQL
--기존 신용한도
SELECT credit_limit 
    FROM customers_copy 
WHERE customer_id=11;
--
CREDIT_LIMIT
------------
       22000
--한도를 2배를 늘릴경우 트리거 발동
UPDATE
    customers_copy
set
    credit_limit = credit_limit*2
WHERE
    customer_id=11;

ORA-20101: the new credit44000 cannot increase to more than double, the current credit 22000
ORA-06512: "C##OT.CUTOMSERS_UPDATE_CREDIT_TRG",  4행
ORA-04088: 트리거 'C##OT.CUTOMSERS_UPDATE_CREDIT_TRG'의 수행시 오류
```

## 트리거 형식 - 4 INSTEAD OF 트리거
```
INSTEAD OF 트리거는 DML문을 통해서 직접 수정할수 없는 VIEW를 통해서
테이블의 데이터를 업데이트 할수있게 한다.

--업데이트를 할수없는 VIEW같은 경우 건너뛰고 다른 DML문을 실행한다.
--수정이 가능한 뷰에 각행에 대행 INSTEAD OF 트리거가 발동한다.

INSTEAD OF는 VIEW에서만 사용이 가능하다.
```
__기본 구문__
```SQL
CREATE [OR REPLACE] TRIGGER trigger_name
INSTEAD OF {INSERT | UPDATE | DELETE}
ON view_name
FOR EACH ROW
BEGIN
    EXCEPTION
    ...
END;
```
__예제용 VIEW 생성__
```sql
CREATE VIEW vw_customers AS
    SELECT 
        name, 
        address, 
        website, 
        credit_limit, 
        first_name, 
        last_name, 
        email, 
        phone
    FROM 
        customers
    INNER JOIN contacts USING (customer_id);
```
> VIEW에 값 넣어보기.
```sql
INSERT INTO 
    vw_customers(
        name, 
        address, 
        website, 
        credit_limit, 
        first_name, 
        last_name, 
        email, 
        phone
    )
VALUES(
    'Lam Research',
    'Fremont, California, USA', 
    'https://www.lamresearch.com/',
    2000,
    'John',
    'Smith',
    'john.smith@lamresearch.com',
    '+1-510-572-0200'
);

SQL 오류: ORA-01779: 키-보존된것이 아닌 테이블로 대응한 열을 수정할 수 없습니다
01779. 00000 -  "cannot modify a column which maps to a non key-preserved table"
*Cause:    An attempt was made to insert or update columns of a join view which
           map to a non-key-preserved table.
*Action:   Modify the underlying base tables directly.

--예외 발생
```
> INSTEAD OF 트리거 생성
```sql
CREATE OR REPLACE TRIGGER new_customer_trg
    INSTEAD OF INSERT ON vw_customers
    FOR EACH ROW
DECLARE
    l_customer_id NUMBER;
BEGIN
    --insert a new customer first
    INSERT INTO customers_copy(customer_id,name, address, website, credit_limit)
    --copy테이블이기 때문에 시퀸스와 pk가 지정이 되지 않아서
    --따로 시퀸스를 만들어서 추가를 했다.
    VALUES(CUSTOMERS_COPY_SEQ.NEXTVAL,:NEW.NAME, :NEW.address, :NEW.website, :NEW.credit_limit)
    --RETURNING INTO 절은 INSERT, UPDATE, DELETE문이 
    --실행되면서 삽입, 수정 혹은 삭제된 데이터를 변수에 담는 역할을 수행한다.
    RETURNING customer_id INTO l_customer_id;
    -- insert the contact
    INSERT INTO contacts_copy(first_name, last_name, email, phone, customer_id)
    VALUES(:NEW.first_name, :NEW.last_name, :NEW.email, :NEW.phone, l_customer_id);
    
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE(TO_CHAR(SQLCODE));
            DBMS_OUTPUT.PUT_LINE(SQLERRM);
END;
```
__적용하기__
```SQL
INSERT INTO 
        vw_customers(
            name, 
            address, 
            website, 
            credit_limit, 
            first_name, 
            last_name, 
            email, 
            phone
        )
    VALUES(
        'Lam Research',
        'Fremont, California, USA', 
        'https://www.lamresearch.com/',
        2000,
        'John',
        'Smith',
        'john.smith@lamresearch.com',
        '+1-510-572-0200'
    );
```
__확인하기__
```SQL
SELECT * FROM customers_copy WHERE CUSTOMER_ID>319;
CUSTOMER_ID NAME            ADDRESS                   WEBSITE                        CREDIT_LIMIT
----------- --------------- ------------------------- ------------------------------ ------------
        320 Lam Research    Fremont, California, USA  https://www.lamresearch.com/           2000
        321 Lam Research    Fremont, California, USA  https://www.lamresearch.com/           2000

--정확이 잘들어가고 있다.
```

## `단일 트리거 비활성화`
> 경우에 따라 테스트 및 문제 해결을 위해 트리거를 비활성화할수 있다.
```sql
ALTER TRIGGER trigger_name DISABLE;
> 예
cutomers의 트리거를 비활성화 한다면
ALTER TRIGGER cutomers_adudit_trg DISABLE;
```
## `테이블의 모든 트리거 비활성화`
```SQL
ALTER TABLE table_name DISABLE ALL TRIGGERS;

> 예 - cutomers의 테이블에 있는 트리거 비활성화
ALTER TABLE cutomers DISABLE ALL TRIGGERS;
```
## `비활성화된 트리거 만들기`
```
업무시간동안 트리거를 만들고 현재 트랜잭션에 영향을 주지 않기위해서
안전하게 하기 위해서 먼저 비활성화 상태에서 트리거를 생성할수 있다.
```
__기본 구문__
```sql
CREATE OR REPLACE TRIGGER trigger_name
    BEFORE | AFTER event
    [FOR EACH ROW]
    DISABLE 
    WHEN (condition)
trigger_body    
```
__예시__
```sql
CREATE OR REPLACE TRIGGER customers_copy_bd_trg
    BEFORE DELETE
    ON customers_copy
    --행 트리거로 행 삭제시마다 매번 트리거 발동
    FOR EACH ROW
    --비활성화
    DISABLE
DECLARE
    l_order_count   PLS_INTEGER;
BEGIN
    --check if the customer has a transaction
    SELECT COUNT(*) INTO l_order_count
    FROM orders
    --DELETE는 :OLD만 사용이 가능하다.
    WHERE customer_id = :OLD.customer_id;
    --회원 테이블에서 삭제려하고 할때 주문거래중이면 삭제할수 없다는 트리거 발동
    --raise an exception if the customer has at least on order
    IF l_order_count > 0 THEN
        raise_application_error(-20010,'Cannot delete customer'|| 
            :OLD.NAME || 'because it already has transactions');
    END IF;
END;
```

## `트리거 활성화`
__기본 구문__
```SQL
ALTER TRIGGER trigger_name ENABLE;
```
__예시__
```SQL
ALTER TRIGGER customers_copy_bd_trg ENABLE;
```
## `테이블의 모든 트리거 활성화`
__기본 구문__
```SQL
ALTER TABLE table_name
ENABLE ALL TRIGGERS;
```
__예시__
```SQL
ALTER TABLE customers
ENABLE ALL TRIGGERS;
```

__`테이블내의 모든 트리거 활성/비활성화는 테이블명을 입력`__

## `트리거 제거`
```SQL
DROP TRIGGER [schema_name.]trigger_name;
/*
트리거가 속한 스키마(사용자)의 이름을 지정할수있는데
건너뛰면 Oracle은 자체 스키마에 있다고 가정합니다. 
해당 트리거가 존재하지 않을경우 ORA-04080 발생

Oracle은 IF EXISTS : 트리거가 존재할 경우에만 삭제하는 옵션 이 없다.
*/
```
```SQL
DROP TRIGGER IF EXISTS trigger_name;
--가 Oracle에는 존재 하지 않는다.
SQL 명령어가 올바르게 종료되지 않았습니다
```
> 프로시저로 트리거가 존재할 경우에만 제거
```sql
CREATE OR REPLACE PROCEDURE drop_trigger_if_exists(
    in_trigger_name VARCHAR2
)
AS
    l_exist PLS_INTEGER;
BEGIN
    -- get the trigger count
    SELECT COUNT(*) INTO l_exist
    FROM user_triggers
    WHERE trigger_name = UPPER(in_trigger_name);
    
    -- if the trigger exist, drop it
    IF l_exist > 0 THEN 
        EXECUTE IMMEDIATE 'DROP TRIGGER ' ||  in_trigger_name;
    END IF;
END;
/
```
__예제__
```SQL
EXEC drop_trigger_if_exists(customers_copy_bd_trg);
```

### `Mutating Table Exception`
```sql
Mutating Table Exception
행 레벨 트리거(Row-Level-Trigger)에서 

변하고 있는 값을 참조하거나     발생되는 오류이다.
                변경하려고 때

INSERT, UPDATE, DELETE 와 같은 DML(데이터 조작어)이 수행되고 
여기에 연결되어 있는 행레벨 트리거에서 
변하는 값을 참조하는 경우 발생하는 오류이다.
ORA-04091: table OT.CUSTOMERS is mutating, 
            trigger/function may not see it
```
## `컴파운드 트리거`
> 해결방법
```
개별 트리거링 타이밍에서 밖에서 선언한 전역 변수에 대해 참조가 가능하므로 
행 레벨 트리거에서 변하는 값들을 전역 변수
(주로 배열처럼 쓰이는 테이블 타입의 컬렉션 변수)에 저장한 후 
명령문 레벨 트리거의 AFTER 타이밍에서 한번에 처리함으로써 
트리거에서 변하고 있는 값을 참조하는 경우 
자주 발생하는 ORA-04091 에러를 방지할 수 있다.
```
__기본 구문__
```SQL
CREATE OR REPLACE TRIGGER 컴파운드_트리거이름
  FOR {INSERT OR UPDATE OR DELETE} ON 테이블명
    COMPOUND TRIGGER
  -- 전역 변수 선언
  g_global_variable VARCHAR2(10);
 
  BEFORE STATEMENT IS   --명령문 레벨 트리거 BEFORE
  BEGIN
    NULL; -- Do something here.
  END BEFORE STATEMENT;
 
  BEFORE EACH ROW IS  --행레벨 트리거 BEFORE
  BEGIN
    NULL; -- Do something here.
  END BEFORE EACH ROW;

  AFTER EACH ROW IS  --행레벨 트리거 AFTER
  BEGIN
    NULL; -- Do something here.
  END AFTER EACH ROW;

  AFTER STATEMENT IS   --명령문 레벨 트리거 AFTER
  BEGIN
    NULL; -- Do something here.
  END AFTER STATEMENT;
 
END <trigger-name>;
/
```
__예시__
```SQL
CREATE OR REPLACE TRIGGER customers_credit_policy_trg
    FOR UPDATE OR INSERT ON customers_copy
    COMPOUND TRIGGER
    --현재 트리거 역할 : 최소 신용한도 * 5 < 입력한 신용한도 일때
    --                  수정, 추가할 id의 신용한도는 = 최소 신용한도 * 5;
    --참조(최소 신용한도) < 테이블 수정시 같이 변경됨
    --매번 입력때마다 신용한도가 변경되기 때문에
    --명령문 레벨 트리거의 AFTER 타이밍에서 한번에 처리한다.

    --그 수정한 id(PK)와 변경할 CREDIT_LIMIT를 레코드에 저장
    TYPE r_customers_type IS RECORD(
        customer_id     customers.customer_id%TYPE,
        credit_limit    customers.credit_limit%TYPE
    );
    --그 레코드를 자료형으로 배열을 만든다.
    TYPE t_customers_type IS TABLE OF r_customers_type
        INDEX BY PLS_INTEGER;
    --변수 t_customer에 객체 참조변수 선언
    t_customer   t_customers_type;
    
    --각 행이 입력,수정될때마다 t_customer 연관 배열에 따로 저장
    AFTER EACH ROW IS
    BEGIN--저장할때마다 idx++ 느낌으로 길이에서 +1을해서 누적으로 배열저장
        t_customer(t_customer.COUNT+1).customer_id  := :NEW.customer_id;
        t_customer(t_customer.COUNT).credit_limit   := :NEW.credit_limit;
    END AFTER EACH ROW;
    
    --다 끝났다면
    AFTER STATEMENT IS
        --조건에 맞는 max_credit을 담을 변수 선언
        l_max_credit    customers.credit_limit%TYPE;
    BEGIN
        --최소값 * 5 를 변수에 담아서 보관
        SELECT MIN(credit_limit)*5 INTO l_max_credit
            FROM customers_copy
        WHERE credit_limit>0;
        --변경된 id를 찾아서 해당 id의 credit_limit를 변경한다.
        FOR idx IN 1..t_customer.COUNT
        LOOP
            IF  l_max_credit < t_customer(idx).credit_limit THEN
                UPDATE customers_copy
                SET credit_limit = l_max_credit
                --if(변경전 id와 수정)
                --추가시 이 블럭은 실행이 되지 않는다.
                WHERE customer_id = t_customer(idx).customer_id;
            END IF;
        END LOOP;
    END AFTER STATEMENT;
END;
```